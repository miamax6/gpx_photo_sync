#!/usr/bin/env python3
"""
GPX ‚Üí Photos (RAW and JPEG) synchronization script
Synchronizes GPS and location metadata from a GPX file to photos

Features:
- Reads GPX file (generated by photo_gps_to_gpx.py)
- Syncs with photos (NEF, JPEG, etc.) by date/time
- Adds GPS + Country/State/City to photos' EXIF and IPTC
- Ignores photos > 1h apart from GPX
- Preserves original files (backup option)
- Compatible with RAW files (NEF, CR2, etc.) via py3exiv2

Usage:
  python sync_gpx_to_photos.py file.gpx photos_folder [--backup] [--dry-run]
  
Dependencies installation:
  pip install Pillow piexif pyexiv2
  
  Note: pyexiv2 works directly on Windows without compilation
"""

import os
import sys
import argparse
from pathlib import Path
from datetime import datetime, timedelta
from xml.etree import ElementTree as ET
from PIL import Image
from PIL.ExifTags import TAGS
import piexif
import pyexiv2

import tempfile, shutil, unicodedata
from datetime import datetime
import logging
from logging.handlers import RotatingFileHandler

def setup_logging(gpx_file):
    """
    Sets up logging to both console and file
    File will be created in the same directory as the GPX file
    """
    log_dir = os.path.dirname(os.path.abspath(gpx_file))
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_file = os.path.join(log_dir, f"sync_{timestamp}.log")
    
    # Configure logging format
    log_format = '%(asctime)s - %(message)s'
    date_format = '%Y-%m-%d %H:%M:%S'
    
    # Create file handler
    file_handler = RotatingFileHandler(log_file, maxBytes=1024*1024, backupCount=5)
    file_handler.setFormatter(logging.Formatter(log_format, date_format))
    
    # Configure root logger
    logging.root.setLevel(logging.INFO)
    logging.root.addHandler(file_handler)
    
    return log_file

# Maximum time difference threshold for synchronization (in seconds)
MAX_TIME_DIFF_SECONDS = 3600  # 1 hour

class GPXPoint:
    """Represents a GPX point with all its metadata"""
    
    def __init__(self, lat, lon, time, altitude=None, city=None, state=None, country=None, country_code=None):
        self.lat = lat
        self.lon = lon
        self.time = time
        self.altitude = altitude
        self.city = city
        self.state = state
        self.country = country
        self.country_code = country_code
    
    def __repr__(self):
        return f"GPXPoint({self.lat:.4f}, {self.lon:.4f}, {self.time}, {self.city}, {self.country})"

def parse_gpx(gpx_file):
    """Parses a GPX file and extracts all points with metadata"""
    points = []
    
    try:
        tree = ET.parse(gpx_file)
        root = tree.getroot()
        
        # Display namespace for debug
        print(f"   üîç Root tag: {root.tag}")
        
        # Handle GPX namespaces
        ns = {'gpx': 'http://www.topografix.com/GPX/1/1'}
        
        # Find all trackpoints with and without namespace
        trkpts = root.findall('.//gpx:trkpt', ns)
        if not trkpts:
            trkpts = root.findall('.//{http://www.topografix.com/GPX/1/1}trkpt')
        if not trkpts:
            trkpts = root.findall('.//trkpt')
        
        print(f"   üîç Found {len(trkpts)} raw trackpoints")
        
        for idx, trkpt in enumerate(trkpts):
            try:
                lat = float(trkpt.get('lat'))
                lon = float(trkpt.get('lon'))
            except:
                continue
            
            # Debug: show children of first trkpt
            if idx == 0:
                print(f"   üîç First trkpt contains: {[child.tag for child in trkpt]}")
            
            # Altitude (optional)
            altitude = None
            for child in trkpt:
                if 'ele' in child.tag.lower():
                    try:
                        altitude = float(child.text)
                    except:
                        pass
                    break
            
            # Time (required for sync) - try all possible ways
            time_elem = None
            for child in trkpt:
                if 'time' in child.tag.lower():
                    time_elem = child
                    break
            
            if time_elem is None or not time_elem.text:
                if idx < 5:  # Only show first 5 to avoid spam
                    print(f"   ‚ö†Ô∏è  Skipping point without timestamp: {lat}, {lon}")
                continue
            
            try:
                # Parse time (ISO 8601 format)
                time_str = time_elem.text.strip()
                # Handle different formats
                if time_str.endswith('Z'):
                    time_str = time_str[:-1]
                point_time = datetime.fromisoformat(time_str)
            except Exception as e:
                if idx < 5:
                    print(f"   ‚ö†Ô∏è  Error parsing date '{time_elem.text}': {e}")
                continue
            
            # Description (contains city, state, country)
            desc_elem = None
            for child in trkpt:
                if 'desc' in child.tag.lower():
                    desc_elem = child
                    break
            
            city = None
            state = None
            country = None
            country_code = None
            
            if desc_elem is not None and desc_elem.text:
                # Format: "City, State, Country (CODE)" or "City, Country (CODE)"
                desc = desc_elem.text.strip()
                
                # Extract country code
                if '(' in desc and ')' in desc:
                    country_code = desc[desc.rfind('(')+1:desc.rfind(')')].strip()
                    desc = desc[:desc.rfind('(')].strip().rstrip(',').strip()
                
                # Parse city, state, country
                parts = [p.strip() for p in desc.split(',') if p.strip()]
                if len(parts) >= 3:
                    city, state, country = parts[0], parts[1], parts[2]
                elif len(parts) == 2:
                    city, country = parts[0], parts[1]
                elif len(parts) == 1:
                    city = parts[0]
            
            point = GPXPoint(lat, lon, point_time, altitude, city, state, country, country_code)
            points.append(point)
        
        print(f"üìç {len(points)} valid GPX points loaded from {gpx_file}")
        if points:
            print(f"   üìÖ Period: {points[0].time} ‚Üí {points[-1].time}")
        return points
    
    except Exception as e:
        print(f"‚ùå Error reading GPX file: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

def find_closest_gpx_point(photo_time, gpx_points, max_diff_seconds=MAX_TIME_DIFF_SECONDS):
    """Finds closest GPX point to a photo (by time)"""
    if not photo_time:
        return None, None
    
    closest_point = None
    min_diff = float('inf')
    
    for point in gpx_points:
        diff = abs((photo_time - point.time).total_seconds())
        if diff < min_diff:
            min_diff = diff
            closest_point = point
    
    # Check if difference is acceptable
    if min_diff <= max_diff_seconds:
        return closest_point, min_diff
    else:
        return None, min_diff

def get_photo_datetime(image_path):
    """Extracts date/time from a photo's EXIF"""
    try:
        # Try with piexif first (more reliable for NEF)
        exif_dict = piexif.load(str(image_path))
        for tag in ["DateTimeOriginal", "DateTimeDigitized", "DateTime"]:
            if tag in piexif.ExifIFD.__dict__:
                key = piexif.ExifIFD.__dict__[tag]
                if key in exif_dict["Exif"]:
                    dt_bytes = exif_dict["Exif"][key]
                    if isinstance(dt_bytes, bytes):
                        dt_str = dt_bytes.decode(errors="ignore")
                    else:
                        dt_str = str(dt_bytes)
                    try:
                        return datetime.strptime(dt_str, "%Y:%m:%d %H:%M:%S")
                    except:
                        pass
        
        # Fallback to Pillow
        image = Image.open(image_path)
        exif_data = image.getexif()
        if not exif_data:
            return None
        
        for key, value in exif_data.items():
            tag = TAGS.get(key, key)
            if tag in ["DateTimeOriginal", "DateTimeDigitized", "DateTime"]:
                dt_str = value.decode() if isinstance(value, bytes) else str(value)
                try:
                    return datetime.strptime(dt_str, "%Y:%m:%d %H:%M:%S")
                except:
                    pass
        
        return None
    except Exception as e:
        print(f"   [DEBUG] Error reading EXIF: {e}")
        return None

def decimal_to_dms_string(decimal, is_latitude):
    """Converts decimal coordinates to DMS string format for EXIF"""
    is_positive = decimal >= 0
    decimal = abs(decimal)
    
    degrees = int(decimal)
    minutes_decimal = (decimal - degrees) * 60
    minutes = int(minutes_decimal)
    seconds = (minutes_decimal - minutes) * 60
    
    # Format: "deg/1 min/1 sec/100"
    dms = f"{degrees}/1 {minutes}/1 {int(seconds * 100)}/100"
    
    # Reference
    if is_latitude:
        ref = 'N' if is_positive else 'S'
    else:
        ref = 'E' if is_positive else 'W'
    
    return dms, ref

def update_photo_metadata(image_path, gpx_point, backup=True, dry_run=False):
    """Updates EXIF and IPTC metadata of a photo (NEF, JPEG, etc.) with pyexiv2"""
    try:
        # Backup if requested
        if backup and not dry_run:
            backup_path = str(image_path) + '.backup'
            if not os.path.exists(backup_path):
                shutil.copy2(image_path, backup_path)
        
        if dry_run:
            print(f"      [DRY-RUN] Simulated modification")
            logging.info(f"[DRY-RUN] Would modify: {os.path.basename(image_path)}")
            return True
        
        # Always use temporary file for better performance
        tmpdir = tempfile.mkdtemp()
        tmpfile = os.path.join(tmpdir, os.path.basename(image_path))
        shutil.copy2(image_path, tmpfile)
        work_path = tmpfile

        # Open image with pyexiv2
        img = pyexiv2.Image(work_path)
        
        # === Update GPS EXIF tags ===
        exif_dict = {}
        
        # GPS coordinates
        lat_dms, lat_ref = decimal_to_dms_string(gpx_point.lat, True)
        lon_dms, lon_ref = decimal_to_dms_string(gpx_point.lon, False)
        
        exif_dict['Exif.GPSInfo.GPSVersionID'] = '2 3 0 0'
        exif_dict['Exif.GPSInfo.GPSLatitude'] = lat_dms
        exif_dict['Exif.GPSInfo.GPSLatitudeRef'] = lat_ref
        exif_dict['Exif.GPSInfo.GPSLongitude'] = lon_dms
        exif_dict['Exif.GPSInfo.GPSLongitudeRef'] = lon_ref
        
        # Altitude (if available)
        if gpx_point.altitude is not None:
            exif_dict['Exif.GPSInfo.GPSAltitude'] = f"{int(abs(gpx_point.altitude) * 100)}/100"
            exif_dict['Exif.GPSInfo.GPSAltitudeRef'] = '0' if gpx_point.altitude >= 0 else '1'
        
        # Write EXIF
        img.modify_exif(exif_dict)
        
        # === Update IPTC tags ===
        iptc_dict = {}
        
        # City
        if gpx_point.city:
            iptc_dict['Iptc.Application2.City'] = gpx_point.city
        
        # Province/State
        if gpx_point.state:
            iptc_dict['Iptc.Application2.ProvinceState'] = gpx_point.state
        
        # Country Name
        if gpx_point.country:
            iptc_dict['Iptc.Application2.CountryName'] = gpx_point.country
        
        # Country Code
        if gpx_point.country_code:
            iptc_dict['Iptc.Application2.CountryCode'] = gpx_point.country_code
        
        # Write IPTC
        if iptc_dict:
            img.modify_iptc(iptc_dict)
        
        # Close and save
        img.close()

        # If using temporary file, copy result back
        if use_temp:
            shutil.move(work_path, image_path)
        
        print(f"      ‚úì GPS and IPTC updated")
        return True
    
    except Exception as e:
        print(f"      ‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
        return False

def process_photos(photos_folder, gpx_points, backup=True, dry_run=False):
    """Processes all photos in a folder"""
    # Supported extensions (RAW and JPEG)
    extensions = ('.nef', '.NEF', '.jpg', '.jpeg', '.JPG', '.JPEG', '.cr2', '.CR2', '.arw', '.ARW')
    
    print(f"\nüîç Searching for photos in: {photos_folder}")
    
    photo_files = list(Path(photos_folder).rglob('*'))
    photo_files = [f for f in photo_files if f.suffix in extensions and '.backup' not in str(f)]
    
    print(f"   Found {len(photo_files)} photos\n")
    
    stats = {
        'total': len(photo_files),
        'synced': 0,
        'skipped_no_date': 0,
        'skipped_too_far': 0,
        'errors': 0
    }
    
    for photo_path in photo_files:
        print(f"üì∏ {photo_path.name}")
        
        # Get photo date
        photo_time = get_photo_datetime(photo_path)
        
        if not photo_time:
            print(f"   ‚ö†Ô∏è  No EXIF date found - SKIPPED")
            stats['skipped_no_date'] += 1
            continue
        
        # Find closest GPX point
        closest_point, time_diff = find_closest_gpx_point(photo_time, gpx_points)
        
        if closest_point is None:
            print(f"   ‚è±Ô∏è  Time difference > 1h ({time_diff/60:.1f} min) - SKIPPED")
            stats['skipped_too_far'] += 1
            continue
        
        # Show info
        print(f"   ‚úì Match found (difference: {time_diff:.0f}s)")
        print(f"   üìç GPS: {closest_point.lat:.6f}, {closest_point.lon:.6f}")
        if closest_point.city or closest_point.country:
            loc_parts = []
            if closest_point.city:
                loc_parts.append(closest_point.city)
            if closest_point.state:
                loc_parts.append(closest_point.state)
            if closest_point.country:
                loc_parts.append(f"{closest_point.country} ({closest_point.country_code})")
            print(f"   üåç Location: {', '.join(loc_parts)}")
        
        # Update metadata
        if update_photo_metadata(photo_path, closest_point, backup=backup, dry_run=dry_run):
            stats['synced'] += 1
        else:
            stats['errors'] += 1
        
        print()
    
    return stats

def main():
    start_time = datetime.now()
    parser = argparse.ArgumentParser(
        description='Synchronize a GPX file with photos (RAW/JPEG)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python sync_gpx_to_photos.py track.gpx M:\\Photos\\NIKON\\2018
  python sync_gpx_to_photos.py track.gpx M:\\Photos\\NIKON\\2018 --backup
  python sync_gpx_to_photos.py track.gpx M:\\Photos\\NIKON\\2018 --dry-run

Installation:
  pip install Pillow piexif pyexiv2

Notes:
  - Photos > 1h apart from GPX are ignored
  - Script takes the closest GPX point by date/time
  - --backup option creates .backup copies of original photos
  - --dry-run simulates without modifying photos
  - Compatible with NEF, CR2, ARW, JPEG and other formats supported by exiv2
  - IPTC tags written: City, Province/State, Country Name, Country Code
        """
    )
    
    parser.add_argument('gpx_file', help='Source GPX file')
    parser.add_argument('photos_folder', help='Folder containing photos to synchronize')
    parser.add_argument('--backup', action='store_true', help='Create backup of original photos')
    parser.add_argument('--dry-run', action='store_true', help='Simulate without modifying photos')
    
    args = parser.parse_args()
    
    # Checks
    if not os.path.exists(args.gpx_file):
        print(f"‚ùå Error: GPX file '{args.gpx_file}' does not exist")
        sys.exit(1)
    
    if not os.path.exists(args.photos_folder):
        print(f"‚ùå Error: Folder '{args.photos_folder}' does not exist")
        sys.exit(1)
    
    # Setup logging
    log_file = setup_logging(args.gpx_file)
    
    print("=" * 70)
    print("üì∑ SYNC GPX ‚Üí PHOTOS (RAW/JPEG)")
    if args.dry_run:
        print("üîç DRY-RUN MODE (simulation)")
    if args.backup:
        print("üíæ BACKUP MODE enabled")
    print("=" * 70)
    
    # Log initial information
    logging.info("=" * 50)
    logging.info("GPX Photo Sync Started")
    logging.info("=" * 50)
    logging.info(f"GPX File: {os.path.abspath(args.gpx_file)}")
    logging.info(f"Photos Folder: {os.path.abspath(args.photos_folder)}")
    logging.info(f"Backup Mode: {'enabled' if args.backup else 'disabled'}")
    logging.info(f"Dry Run: {'yes' if args.dry_run else 'no'}")
    
    # Load GPX
    gpx_points = parse_gpx(args.gpx_file)
    
    if not gpx_points:
        print("‚ùå No GPX points found in file")
        sys.exit(1)
    
    # Process photos
    stats = process_photos(args.photos_folder, gpx_points, backup=args.backup, dry_run=args.dry_run)
    
    # Calculate execution time
    end_time = datetime.now()
    execution_time = (end_time - start_time).total_seconds()

    # Show summary
    print("=" * 70)
    print("üìä SUMMARY")
    print("=" * 70)
    print(f"Total photos:          {stats['total']}")
    print(f"‚úÖ Synchronized:       {stats['synced']}")
    print(f"‚è±Ô∏è  Skipped (> 1h):     {stats['skipped_too_far']}")
    print(f"‚ö†Ô∏è  Skipped (no date): {stats['skipped_no_date']}")
    print(f"‚ùå Errors:             {stats['errors']}")
    print()
    
    # Log summary
    logging.info("\n" + "=" * 50)
    logging.info("OPERATION SUMMARY")
    logging.info("=" * 50)
    logging.info(f"Total photos processed: {stats['total']}")
    logging.info(f"Successfully synchronized: {stats['synced']}")
    logging.info(f"Skipped (time diff > 1h): {stats['skipped_too_far']}")
    logging.info(f"Skipped (no date): {stats['skipped_no_date']}")
    logging.info(f"Errors encountered: {stats['errors']}")
    logging.info(f"Total execution time: {execution_time:.1f} seconds")
    
    if args.dry_run:
        print("‚ÑπÔ∏è  Dry-run mode: No photos were modified")
        logging.info("Dry-run mode: No photos were modified")
    elif stats['synced'] > 0:
        print("üéâ Synchronization completed!")
        logging.info("Synchronization completed successfully")
        if args.backup:
            print("üíæ Backup files (.backup) contain originals")
            logging.info("Backup files (.backup) created for all processed photos")
    
    print(f"\nLog file created: {log_file}")
    print()

if __name__ == '__main__':
    main()